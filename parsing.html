<!DOCTYPE html>
<!-- saved from url=(0034)http://appcabinet.com/parsing.html -->
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <title></title>
    <link rel="stylesheet" href="css/vendor/bootstrap.css" />

    <!-- CSS → Font Awesome -->
    <!-- dependencies: bootstrap -->
    <link rel="stylesheet" href="css/vendor/font-awesome.css" />
    <link rel="stylesheet" href="css/vendor/font-awesome-ie7.css" />

    <!-- CSS → Bootstrap Overrides (changing main bootstrap CSS) -->
    <!-- dependencies: bootstrap3 -->
    <link rel="stylesheet" href="css/overrides/bootstrap-overrides.css" />

    <!-- CSS → HTML5 Admin_ core -->
    <!-- dependencies: bootstrap3, font-awesome + others depending on which plugins are used in the page -->
    <!--     <link rel="stylesheet" href="css/html5admin.css" />
    <link rel="stylesheet" href="css/vendor/jstree.css" /> -->
    <script src="js/vendor/jquery.min.js"></script>
    <script src="thought.js"></script>

</head>

<body style="">
    <div class="row" style="position:relative;left:100px;">
        
        <div class="col-md-12">

            <div id="topic-container" class="tree-container">
            </div>

            <div id="topic-tree" class="tree">
            </div>


            
<textarea class="braindump" rows="10" cols="80" autofocus="autofocus"></textarea>

    </div>

    <script type="text/javascript">
    function ParsedLine(level, text, previous) {
        this.level = level;
        this.text = text;
        this.previous = previous;
        this.children = [];
    }

    ParsedLine.prototype.adjustLevel = function() {
        if (this.previous === null) {
            return this.level = 0;
        } else if (this.level - this.previous.level > 1) {
            return this.level = this.previous.level + 1;
        }
    };

    ParsedLine.prototype.parentOf = function(child) {
        return (child.level - this.level) === 1;
    };

    ParsedLine.prototype.addChild = function(child) {
        return this.children.push(child);
    };

    ParsedLine.prototype.linkToParent = function() {
        var prev;
        if (this.previous == null) {
            return null;
        }
        prev = this.previous;
        while (prev) {
            if (prev.parentOf(this)) {
                prev.addChild(this);
                return prev;
            } else {
                prev = prev.previous;
            }
        }
    };

    ParsedLine.prototype.serialize = function() {
        var child;
        return {
            text: this.text,
            children: (function() {
                var _i, _len, _ref, _results;
                _ref = this.children;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    child = _ref[_i];
                    _results.push(child.serialize());
                }
                return _results;
            }).call(this)
        };
    };

    ParsedLine.analyze = function(line) {
        var r;
        r = line.match(/^(\t+)(.*)/);
        if (r != null) {
            return {
                level: r[1].length,
                text: r[2].trim()
            };
        } else {
            return {
                level: 0,
                text: line.trim()
            };
        }
    };

    ParsedLine.build = function(rawText, previous) {
        var level, line, text, _ref;
        this.previous = previous;
        _ref = this.analyze(rawText), level = _ref.level, text = _ref.text;
        line = new ParsedLine(level, text, this.previous);
        line.adjustLevel();
        line.linkToParent();
        return line;
    };

    function Parser() {}

    Parser.prototype.toLines = function(content) {
        var prevLine;
        prevLine = null;
        return content.split('\n').map(function(line) {
            var current;
            current = ParsedLine.build(line, prevLine);
            return prevLine = current;
        });
    };

    Parser.prototype.serialize = function(content) {
        var line, _i, _len, _ref, _results;
        _ref = this.toLines(content);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            line = _ref[_i];
            if (line.level === 0) {
                _results.push(line.serialize());
            }
        }
        return _results;
    };


    $(".braindump").keydown(function(e) {
        var content;
        var $this = $(this);
        var value = $this.val();
        if (e.keyCode === 9) { // tab was pressed
            // get caret position/selection
            var start = this.selectionStart;
            var end = this.selectionEnd;

            // set textarea value to: text before caret + tab + text after caret
            content = value.substring(0, start) + "\t" + value.substring(end);
            $this.val(content);

            // put caret at right position again (add one for the tab)
            this.selectionStart = this.selectionEnd = start + 1;

            // prevent the focus lose
            e.preventDefault();
        } else {
            content = value;
        };
    });

    $(".braindump").keyup(function() {
        var p = new Parser();
        var jsonValue = p.serialize($(this).val());
        renderJsonAsTree(jsonValue);
    });
    </script>


</body>

</html>
